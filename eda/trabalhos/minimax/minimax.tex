\documentclass[sigplan,screen]{acmart}

\usepackage[ruled]{algorithm2e}
\renewcommand{\algorithmcfname}{ALGORITHM}
%% Remove Permissions and ACM Reference Notes
\renewcommand\footnotetextcopyrightpermission[1]{}
\settopmatter{printacmref=false}
%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

\begin{document}

\title{Árvores Minimax para Jogos de Soma Zero}
\subtitle{DIM0806 - Estruturas de Dados e Algoritmos}

\author{Tiago Vinícius Remígio da Costa}
\email{vinicius.remigio@gmail.com}
\affiliation{
  \institution{DIMAp - Universidade Federal do Rio Grande do Norte}
  \city{Natal}
  \state{RN}
  \country{Brasil}
}

\begin{abstract}
  Árvores minimax tem sido usadas em conceitos de jogos de soma zero. 
  Neste trabalho veremos algumas implicações desta estrutura de dados, 
  assim como pseudo-código e exemplos de utilização em problemas reais.
\end{abstract}

\keywords{algoritmos, estruturas de dados, árvores}

\maketitle
\pagestyle{plain}

\section{Introdução}
Este trabalho apresenta o algoritmo minimax para jogos de soma zero. 
Obter algoritmos que calculem uma estratégia capaz de recomendar uma ação para qualquer estado.
As demais seções são Funcionamento, incluindo pseudocódigo, Complexidade, Trade-offs, Aplicações e por fim as Conclusões do trabalho.

\subsection{Soma Zero}
Em um jogo determinístico de soma zero, o placar final de um jogo em que dois jogadores são adversários.
para cada jogador pode ser vitória {\itshape(1 ponto)}, empate {\itshape(0 pontos)} ou derrota {\itshape(-1 ponto)}. 
Agentes jogadores possuem utilidades opostas. Isso permite que a função utilidade seja a mesma.

Além disso, os métodos de busca são sempre adversários, puramente competitivos, onde cada jogador está tentando ganhar e também provocando a derrota do oponente.

Considerando essa premissa, o placar total deve ser sempre zero.

\section{Algoritmo Minimax}
Em uma busca minimax, a árvore representa o espaço de estados, onde os jogadores se alternam nos movimentos e o valor minimax é computado para cada nó, onde se busca a melhor utilidade contra um agente adversário ótimo, ou seja, a premissa é que o adversário jogue de forma racional
Para definir Minimax, necessitaremos de alguns conceitos.
\begin{itemize}
  \item{Estados: S, onde S0 é o estado inicial;}
  \item{Jogadores: P = {1...N}}
  \item{Ações: A}
  \item{Função de Transição: SxA -> S}
  \item{Teste de parada: S -> {t,f}}
  \item{Utilidades terminais: SxP -> R}
\end{itemize}

Solução par aum jogador é uma política: S -> A

Exatamente como DFS, tornando inviável quando a árvore é profunda
Tempo: O(b elevado a m)
Espaço: O(bm)

Para isso, técnicas de poda são necessárias ao se trabalhar como representação minimax.

\subsection{Pseudo-código}
O pseudocódigo do algoritmo Minimax segue como na imagem abaixo. 
As funções {\itshape minValue} e {\itshape maxValue} possuem o mesmo funcionamento, apenas invertendo a lógica.

\begin{algorithm}
\DontPrintSemicolon
  \caption{Algoritmo Minimax}
  \label{alg:generator}
  \SetKwProg{minimax}{Function \emph{minimax}}{}{end}
  \minimax{Object state}{
    \If{ state $s$ is final}{
        \Return{$s$}\;
    }
    minValue($s$)\;
    maxValue($s$)\;
  }

  \SetKwProg{maxValue}{maxValue}{}{}
  \maxValue{$s$}{
    init v = -inf\;
    \ForEach{successor in s}{
      v = max(v, value(successor))\;
    }
    \KwRet{v}\;
  }

  \SetKwProg{minValue}{minValue}{}{}
  \minValue{$s$}{
    init v = +inf\;
    \ForEach{successor in s}{
      v = min(v, value(successor))\;
    }
    \KwRet{v}\;
  }
\end{algorithm}


\section{Trade-offs}

Em problemas reais, é impossível busacar até as folhas. 
Uma solução é trabalhar com busca em profundidade limitada, substituir por uma função de avaliação para posições que não são folhas.
Não há garantia que o resultado será ótimo, por isso aumentar a profundidade faz bastante diferença.

Se a profundidade for maior, a complexidade da função pode ser menor. Mas se a poda for mais rasa, a função de avaliação precisaria ser mais complexa. 
Acarretando maior capacidade de computação. 
O ideal é chegar uma ponderação na qual consiga-se descer para uma maior profundidade e que a função não seja muito complexa de calcular.

Funções de avaliação pontuam estados não-terminais na busca de profundidade limitada.
FUnção ideal retornaria o valor minimax real da posição.

\subsection{Poda Alfa-Beta}
Computando o valor MIN em algum nó N
Percorrer os filhos de N
A estimativa de n a respeito do valor MIN de seus filhos está Considerando
O valor de N é importante para MAX
Seja a o melhor valor de MAX em qualquer ponto até a raiz
Se n se torna pior que a, MAX irá evitá-lo, então podemos parar de considerar os demais filhos de n

Propriedades da poda alfa-beta
Não afeta o minimax para raíz
Valores dos nós intermediários podem estar errados

\section{Aplicações}
Muito utilizado em Teoria dos Jogos, na modelagem de problemas de adversários, comum em sistemas multiagentes, na economia.

\section{Conclusão}
O algoritmo Minimax utiliza árvores como estrutura de dados e busca representar dois agentes que buscam vencer, provocando a derrota do outro, em um jogo de soma zero. 
Este conceito tem sido bastante estudado na Economia, através da Teoria dos Jogos. 

\section{Referências}
\begin{itemize}
  \item {Árvores de Jogos Minimax e Poda Alfa-Beta (UFES)}\
  \item {Aula de Busca Competitiva (Árvores minimax) Sérgio Queiroz, CIn-UFPE}\
  \item {Artificial Intelligence: A modern approach, Russel Norvig}\
\end{itemize}

\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-base}

\end{document}
\endinput
